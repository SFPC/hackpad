<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="en-us" />
<meta name="version" content="190"/>
<style>body {font-family:Helvetica}ul.comment{list-style-image:url('https://hackpad.com/static/img/comment.png');} ul.task{list-style-image:url('https://hackpad.com/static/img/unchecked.png');}ul.taskdone{list-style-image:url('https://hackpad.com/static/img/checked.png');} </style><title>/3668$mnhn6AOJb47</title>
</head>
<body><h1>OF / GLSL study group</h1><p></p><p><b>Tutorial:</b></p><p><a href="http://www.openframeworks.cc/tutorials/graphics/shaders.html"></a>http://www.openframeworks.cc/tutorials/graphics/shaders.html</p><p></p><p><b>GLSL instruction from Zach:</b></p><p>*</p><p><a href="https://soundcloud.com/motoititvcc/20131003-zach-glsl"></a>https://soundcloud.com/motoititvcc/20131003-zach-glsl</p><p></p><p><b>Our Repos:</b></p><ul><li>Motoi: <a href="https://github.com/motoishmz/sfpc-2013/tree/master/shader"></a><a href='https://github.com/motoishmz/glsl'/>https://github.com/motoishmz/sfpc-2013/tree/master/shader</a></li>
<li>Jason: <a href="https://github.com/jasonlevine/glsl-lesson"></a>https://github.com/jasonlevine/glsl-lesson</li></ul>

<p><b>Questions:</b></p><ul><li>ofVbo vs ofMesh</li>
<li>ofVbo vs ofVboMesh</li>
<li>glsl verstion 120 vs glsl verstion 150</li></ul>

<p><b><u>What Is GLSL?</u></b></p><p>GLSL (GLslang) is a short term for the official OpenGL Shading Language. GLSL is a C/C++ similar high level programming language for several parts of the graphic card. With GLSL you can code (right up to) short programs, called shaders, which are executed on the GPU.</p><p><b><u>Why Shaders?</u></b></p><p>Until DirectX 8 hardware (GeForce 2 and lower, Radoen 7000 and lower) the graphic pipeline could only be configured, but not be programmed. For example there is the OpenGL lighting model with ambient, diffuse, specular and emissive lighting. This model is mainly used but there are many other models for lighting. In fixed-function OpenGL only this lighting model could be used, no other. With Shaders you are able to write your own lighting model. But thatÂ’s only one feature of shaders. There are thousands of other really nice possibilities: Shadows, Environment Mapping, Per-Pixel Lighting, Bump Mapping, Parallax Bump Mapping, HDR, and much more!</p><p><b><u>Why GLSL?</u></b></p><p>Shaders are available in OpenGL till 2002 through ARB_vertex_program and ARB_fragment_program extension. But with those extensions you are only able to use assembly shaders. Because of the growing complexity of lighting and shading models assembly shaders are hard to use. GLSL is a high-level shading language, which means that you can write your shader in C/C++ style. This makes shader development much easier!</p><p><b><u>Data Types In GLSL</u></b></p><p>There are four main types: float, int, bool and sampler. For the first three types, vector types are available:</p><p>vec2, vec3, vec4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2D, 3D and 4D floating point vector</p><p>ivec2, ivec3, ivec4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2D, 3D and 4D integer vector</p><p>bvec2, bvec3, bvec4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2D, 3D and 4D boolean vectors</p><p>For floats here are also matrix types:</p><p>mat2, mat3, mat4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2x2, 3x3, 4x4 floating point matrix</p><p>Samplers are types representing textures. They are used for texture sampling. Sampler types have to be uniform. They are not allowed to be declared as a non-uniform type. Here are the different sampler types:</p><p>sampler1D, sampler2D, sampler3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1D, 2D and 3D texture</p><p>samplerCube&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cube Map texture</p><p>sampler1Dshadow, sampler2Dshadow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1D and 2D depth-component texture</p><p><b><u>About Attributes, Uniforms And Varyings</u></b></p><p>There are three types of inputs and outputs in a shader: uniforms, attributes and varyings.</p><p>Uniforms are values which do not change during a rendering, for example the light position or the light color. Uniforms are available in vertex and fragment shaders. Uniforms are read-only.</p><p>Attributes are only available in vertex shader and they are input values which change every vertex, for example the vertex position or normals. Attributes are read-only.</p><p>Varyings are used for passing data from a vertex shader to a fragment shader. Varyings are (perspective correct) interpolated across the primitive. Varyings are read-only in fragment shader but are read- and writeable in vertex shader (but be careful, reading a varying type before writing to it will return an undefined value). If you want to use varyings you have to declare the same varying in your vertex shader and in your fragment shader.</p><p>All uniform, attribute and varying types HAVE to be global. You are not allowed to specify a uniform/attribute/varying type in a function or a void.</p><p></p><p></p></body>
</html>
